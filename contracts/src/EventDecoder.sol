pragma solidity 0.8.17;

import { Memory } from "solidity-merkle-trees/src/trie/Memory.sol";
import { ByteSlice, Bytes } from "solidity-merkle-trees/src/trie/Bytes.sol";
import { ScaleCodec } from "solidity-merkle-trees/src/trie/substrate/ScaleCodec.sol";
import { MAX_NUM_PROOF_NODES, NUM_AUTHORITIES } from "src/Constants.sol";
import "src/SubstrateTrieDB.sol";
import "src/NibbleSlice.sol";

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "solidity-merkle-trees/src/trie/Bytes.sol";
import "solidity-merkle-trees/src/trie/Node.sol";
import { NibbleSliceOps as NibbleSliceOpsOriginal } from "solidity-merkle-trees/src/trie/NibbleSlice.sol";


import "solidity-merkle-trees/src/trie/Option.sol";
import "solidity-merkle-trees/src/trie/TrieDB.sol";

import "solidity-merkle-trees/src/trie/substrate/Blake2b.sol";
import { SubstrateTrieDB as SubstrateTrieDBOriginal } from "solidity-merkle-trees/src/trie/substrate/SubstrateTrieDB.sol";


/// @title Event Scale Decoder
/// @author Succinct Labs
/// @notice This function is used to scale decode events.
contract EventDecoder {
    enum chunkType{ CONSTANT_SIZE, COMPACT, SEQUENCE }

    struct Chunk {
        chunkType chunkType;
        uint32 size;
        Chunk[] sequenceChunks;
    }

    mapping(uint8 => mapping(uint8 => Chunk[])) eventChunks;

    /// @notice This function is generated by the program utils/gen_avail_event_types.rs
    constructor() {
        eventChunks[0][0].push();
        eventChunks[0][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][0][0].size = 4;
        eventChunks[0][0].push();
        eventChunks[0][0][1].chunkType = chunkType.COMPACT;
        eventChunks[0][0].push();
        eventChunks[0][0][2].chunkType = chunkType.COMPACT;
        eventChunks[0][0].push();
        eventChunks[0][0][3].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][0][3].size = 2;
        eventChunks[0][1].push();
        eventChunks[0][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][1][0].size = 15;
        eventChunks[0][3].push();
        eventChunks[0][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][3][0].size = 32;
        eventChunks[0][4].push();
        eventChunks[0][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][4][0].size = 32;
        eventChunks[0][5].push();
        eventChunks[0][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][5][0].size = 64;
        eventChunks[1][0].push();
        eventChunks[1][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[1][0][0].size = 9;
        eventChunks[1][3].push();
        eventChunks[1][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[1][3][0].size = 6;
        eventChunks[5][0].push();
        eventChunks[5][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][0][0].size = 36;
        eventChunks[5][1].push();
        eventChunks[5][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][1][0].size = 4;
        eventChunks[5][2].push();
        eventChunks[5][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][2][0].size = 36;
        eventChunks[6][0].push();
        eventChunks[6][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][0][0].size = 48;
        eventChunks[6][1].push();
        eventChunks[6][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][1][0].size = 48;
        eventChunks[6][2].push();
        eventChunks[6][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][2][0].size = 80;
        eventChunks[6][3].push();
        eventChunks[6][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][3][0].size = 64;
        eventChunks[6][4].push();
        eventChunks[6][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][4][0].size = 48;
        eventChunks[6][5].push();
        eventChunks[6][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][5][0].size = 48;
        eventChunks[6][6].push();
        eventChunks[6][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][6][0].size = 81;
        eventChunks[6][7].push();
        eventChunks[6][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][7][0].size = 48;
        eventChunks[6][8].push();
        eventChunks[6][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][8][0].size = 48;
        eventChunks[6][9].push();
        eventChunks[6][9][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][9][0].size = 48;
        eventChunks[9][0].push();
        eventChunks[9][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][0][0].size = 2;
        eventChunks[9][1].push();
        eventChunks[9][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][1][0].size = 2;
        eventChunks[9][2].push();
        eventChunks[9][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][2][0].size = 48;
        eventChunks[9][3].push();
        eventChunks[9][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][3][0].size = 48;
        eventChunks[9][4].push();
        eventChunks[9][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][4][0].size = 4;
        eventChunks[9][5].push();
        eventChunks[9][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][5][0].size = 4;
        eventChunks[10][0].push();
        eventChunks[10][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][0][0].size = 36;
        eventChunks[10][1].push();
        eventChunks[10][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][1][0].size = 48;
        eventChunks[10][2].push();
        eventChunks[10][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][2][0].size = 48;
        eventChunks[10][3].push();
        eventChunks[10][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][3][0].size = 4;
        eventChunks[10][5].push();
        eventChunks[10][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][5][0].size = 48;
        eventChunks[10][6].push();
        eventChunks[10][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][6][0].size = 48;
        eventChunks[10][7].push();
        eventChunks[10][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][7][0].size = 48;
        eventChunks[10][8].push();
        eventChunks[10][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][8][0].size = 64;
        eventChunks[10][10].push();
        eventChunks[10][10][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][10][0].size = 32;
        eventChunks[10][11].push();
        eventChunks[10][11][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][11][0].size = 36;
        eventChunks[11][0].push();
        eventChunks[11][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[11][0][0].size = 4;
        eventChunks[12][0].push();
        eventChunks[12][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][0][0].size = 20;
        eventChunks[12][1].push();
        eventChunks[12][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][1][0].size = 20;
        eventChunks[12][1].push();
        eventChunks[12][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[12][1][1].sequenceChunks.push();
        eventChunks[12][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][1][1].sequenceChunks[0].size = 32;
        eventChunks[12][3].push();
        eventChunks[12][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][3][0].size = 5;
        eventChunks[12][4].push();
        eventChunks[12][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][4][0].size = 4;
        eventChunks[12][5].push();
        eventChunks[12][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][5][0].size = 4;
        eventChunks[12][6].push();
        eventChunks[12][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][6][0].size = 4;
        eventChunks[12][7].push();
        eventChunks[12][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][7][0].size = 10;
        eventChunks[12][8].push();
        eventChunks[12][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][8][0].size = 64;
        eventChunks[12][9].push();
        eventChunks[12][9][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][9][0].size = 32;
        eventChunks[12][10].push();
        eventChunks[12][10][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][10][0].size = 68;
        eventChunks[12][11].push();
        eventChunks[12][11][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][11][0].size = 80;
        eventChunks[12][12].push();
        eventChunks[12][12][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][12][0].size = 80;
        eventChunks[12][13].push();
        eventChunks[12][13][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][13][0].size = 36;
        eventChunks[12][14].push();
        eventChunks[12][14][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][14][0].size = 36;
        eventChunks[12][15].push();
        eventChunks[12][15][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][15][0].size = 112;
        eventChunks[12][16].push();
        eventChunks[12][16][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][16][0].size = 32;
        eventChunks[13][0].push();
        eventChunks[13][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][0][0].size = 72;
        eventChunks[13][1].push();
        eventChunks[13][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][1][0].size = 73;
        eventChunks[13][2].push();
        eventChunks[13][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][2][0].size = 32;
        eventChunks[13][3].push();
        eventChunks[13][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][3][0].size = 32;
        eventChunks[13][4].push();
        eventChunks[13][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][4][0].size = 38;
        eventChunks[13][5].push();
        eventChunks[13][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][5][0].size = 38;
        eventChunks[13][6].push();
        eventChunks[13][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][6][0].size = 40;
        eventChunks[14][0].push();
        eventChunks[14][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][0][0].size = 72;
        eventChunks[14][1].push();
        eventChunks[14][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][1][0].size = 73;
        eventChunks[14][2].push();
        eventChunks[14][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][2][0].size = 32;
        eventChunks[14][3].push();
        eventChunks[14][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][3][0].size = 32;
        eventChunks[14][4].push();
        eventChunks[14][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][4][0].size = 38;
        eventChunks[14][5].push();
        eventChunks[14][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][5][0].size = 38;
        eventChunks[14][6].push();
        eventChunks[14][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][6][0].size = 40;
        eventChunks[15][0].push();
        eventChunks[15][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[15][0][0].sequenceChunks.push();
        eventChunks[15][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][0][0].sequenceChunks[0].size = 48;
        eventChunks[15][3].push();
        eventChunks[15][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][3][0].size = 32;
        eventChunks[15][4].push();
        eventChunks[15][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][4][0].size = 32;
        eventChunks[15][5].push();
        eventChunks[15][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][5][0].size = 48;
        eventChunks[15][6].push();
        eventChunks[15][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][6][0].size = 48;
        eventChunks[17][0].push();
        eventChunks[17][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[17][0][0].sequenceChunks.push();
        eventChunks[17][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[17][0][0].sequenceChunks[0].size = 40;
        eventChunks[18][0].push();
        eventChunks[18][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][0][0].size = 4;
        eventChunks[18][1].push();
        eventChunks[18][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][1][0].size = 16;
        eventChunks[18][2].push();
        eventChunks[18][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][2][0].size = 52;
        eventChunks[18][3].push();
        eventChunks[18][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][3][0].size = 20;
        eventChunks[18][4].push();
        eventChunks[18][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][4][0].size = 16;
        eventChunks[18][5].push();
        eventChunks[18][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][5][0].size = 16;
        eventChunks[18][6].push();
        eventChunks[18][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][6][0].size = 16;
        eventChunks[18][8].push();
        eventChunks[18][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][8][0].size = 32;
        eventChunks[19][0].push();
        eventChunks[19][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][0][0].size = 6;
        eventChunks[19][1].push();
        eventChunks[19][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][1][0].size = 32;
        eventChunks[19][2].push();
        eventChunks[19][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][2][0].size = 6;
        eventChunks[20][0].push();
        eventChunks[20][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][0][0].size = 32;
        eventChunks[20][2].push();
        eventChunks[20][2][0].chunkType = chunkType.SEQUENCE;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][2][0].sequenceChunks[0].size = 32;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[1].chunkType = chunkType.COMPACT;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[2].chunkType = chunkType.COMPACT;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].chunkType = chunkType.SEQUENCE;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[0].size = 32;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[1].chunkType = chunkType.COMPACT;
        eventChunks[22][0].push();
        eventChunks[22][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[22][0][0].size = 16;
        eventChunks[22][0].push();
        eventChunks[22][0][1].chunkType = chunkType.SEQUENCE;
        eventChunks[22][0][1].sequenceChunks.push();
        eventChunks[22][0][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[22][0][1].sequenceChunks[0].size = 1;
        eventChunks[24][0].push();
        eventChunks[24][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][0][0].size = 8;
        eventChunks[24][1].push();
        eventChunks[24][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][1][0].size = 8;
        eventChunks[24][2].push();
        eventChunks[24][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][0].size = 9;
        eventChunks[24][2].push();
        eventChunks[24][2][1].chunkType = chunkType.SEQUENCE;
        eventChunks[24][2][1].sequenceChunks.push();
        eventChunks[24][2][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][1].sequenceChunks[0].size = 1;
        eventChunks[24][2].push();
        eventChunks[24][2][2].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][2].size = 6;
        eventChunks[25][0].push();
        eventChunks[25][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][0][0].size = 4;
        eventChunks[25][1].push();
        eventChunks[25][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][1][0].size = 20;
        eventChunks[25][2].push();
        eventChunks[25][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][2][0].size = 4;
        eventChunks[25][3].push();
        eventChunks[25][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][3][0].size = 36;
        eventChunks[25][4].push();
        eventChunks[25][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][4][0].size = 52;
        eventChunks[25][5].push();
        eventChunks[25][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][5][0].size = 4;
        eventChunks[25][6].push();
        eventChunks[25][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][6][0].size = 4;
        eventChunks[26][0].push();
        eventChunks[26][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][0][0].size = 32;
        eventChunks[26][1].push();
        eventChunks[26][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][1][0].size = 32;
        eventChunks[26][2].push();
        eventChunks[26][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][2][0].size = 80;
        eventChunks[26][3].push();
        eventChunks[26][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][3][0].size = 32;
        eventChunks[26][4].push();
        eventChunks[26][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][4][0].size = 80;
        eventChunks[28][0].push();
        eventChunks[28][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[28][0][0].size = 48;
        eventChunks[29][0].push();
        eventChunks[29][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[29][0][0].sequenceChunks.push();
        eventChunks[29][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][0][0].sequenceChunks[0].size = 1;
        eventChunks[29][0].push();
        eventChunks[29][0][1].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][0][1].size = 32;
        eventChunks[29][0].push();
        eventChunks[29][0][2].chunkType = chunkType.COMPACT;
        eventChunks[29][1].push();
        eventChunks[29][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][1][0].size = 32;
        eventChunks[29][1].push();
        eventChunks[29][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[29][1][1].sequenceChunks.push();
        eventChunks[29][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][1][1].sequenceChunks[0].size = 1;
        eventChunks[29][2].push();
        eventChunks[29][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][2][0].size = 8;
        eventChunks[30][0].push();
        eventChunks[30][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[30][0][0].size = 40;
        eventChunks[30][1].push();
        eventChunks[30][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[30][1][0].size = 32;
        eventChunks[31][0].push();
        eventChunks[31][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][0][0].size = 76;
        eventChunks[31][0].push();
        eventChunks[31][0][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][0][1].sequenceChunks.push();
        eventChunks[31][0][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][0][1].sequenceChunks[0].size = 1;
        eventChunks[31][1].push();
        eventChunks[31][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][1][0].size = 68;
        eventChunks[31][1].push();
        eventChunks[31][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][1][1].sequenceChunks.push();
        eventChunks[31][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][1][1].sequenceChunks[0].size = 1;
        eventChunks[31][2].push();
        eventChunks[31][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][2][0].size = 64;
        eventChunks[31][2].push();
        eventChunks[31][2][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][2][1].sequenceChunks.push();
        eventChunks[31][2][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][2][1].sequenceChunks[0].size = 1;
        eventChunks[31][3].push();
        eventChunks[31][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][3][0].size = 52;
        eventChunks[32][0].push();
        eventChunks[32][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[32][0][0].size = 72;
    }

    /// @notice This function will decode the authority set from the encoded event list
    function decodeAuthoritySet(bytes memory encodedEventList) internal returns (bytes32 digest) {
        ByteSlice memory encodedEventsListSlice = ByteSlice(encodedEventList, 0);

        // First get the length of the encoded_events_list
        uint256 num_events = ScaleCodec.decodeUintCompact(encodedEventsListSlice);

        uint8 phase;
        uint8 palletIndex;
        uint8 eventIndex;

        // Parse the scale encoded events
        for (uint256 i = 0; i < num_events; i++) {
            // First element is the Phase enum value (0 - ApplyExtrinsic, 1 - Finalization, 2 - Initialization)
            phase = Bytes.readByte(encodedEventsListSlice);

            // Second element is the pallet_index
            palletIndex = Bytes.readByte(encodedEventsListSlice);

            // Third element is the event_index
            eventIndex = Bytes.readByte(encodedEventsListSlice);

            // Decode the actual event
            if (phase == 1 && palletIndex == 17 && eventIndex == 0) {
                // This is the NewAuthorities event

                // The next element is the length of the encoded new authorities list
                uint256 numAuthorities = ScaleCodec.decodeUintCompact(encodedEventsListSlice);
                if (numAuthorities != NUM_AUTHORITIES) {
                    revert("Incorrect number of authorities");
                }

                (uint srcAddr,) = Memory.fromBytes(encodedEventsListSlice.data);
                srcAddr += encodedEventsListSlice.offset;
                uint256 msg_len = numAuthorities * 40;

                assembly {
                    digest := keccak256(srcAddr, msg_len)
                }

                break;
            } else {
                for (uint256 chunkIdx = 0; chunkIdx < eventChunks[palletIndex][eventIndex].length; chunkIdx++) {
                    jumpOverChunk(eventChunks[palletIndex][eventIndex][chunkIdx], encodedEventsListSlice);
                }
            }

            // There is a 0 value byte at the end of each event
            require(Bytes.readByte(encodedEventsListSlice) == 0, "last byte of event is not 0");
        }
    }

    /// @notice This function will decode the authority set from the encoded event list
    function decodeAuthoritySetCalldata(bytes calldata encodedEventsList) internal returns (bytes32 digest) {
        uint256 cursor = 0;
        uint256 num_events;
        uint256 bytesRead;
        // First get the length of the encoded_events_list
        (num_events, bytesRead) = ScaleCodec.decodeUintCompactCalldata(encodedEventsList);
        cursor += bytesRead;

        uint8 phase;
        uint8 palletIndex;
        uint8 eventIndex;

        // Parse the scale encoded events
        for (uint256 i = 0; i < num_events; i++) {
            // First element is the Phase enum value (0 - ApplyExtrinsic, 1 - Finalization, 2 - Initialization)
            phase = uint8(encodedEventsList[cursor]);
            cursor += 1;

            // Second element is the pallet_index
            palletIndex = uint8(encodedEventsList[cursor]);
            cursor += 1;

            // Third element is the event_index
            eventIndex = uint8(encodedEventsList[cursor]);
            cursor += 1;

            // Decode the actual event
            if (phase == 1 && palletIndex == 17 && eventIndex == 0) {
                // This is the NewAuthorities event

                // The next element is the length of the encoded new authorities list
                uint256 numAuthorities;
                (numAuthorities, bytesRead) = ScaleCodec.decodeUintCompactCalldata(encodedEventsList);
                cursor += bytesRead;
                /*
                if (numAuthorities != NUM_AUTHORITIES) {
                    revert("Incorrect number of authorities");
                }
                */

                assembly {
                    let ptr := mload(0x40)
                    let msg_len := mul(numAuthorities, 40)
                    // 68 is ther result of the first 4 bytes of calldata is the function signature
                    // The next 32 bytes points to location in calldata where encodedEventsList starts
                    // The next 32 bytes stores the size of encodedEventsList
                    // See https://medium.com/@kalexotsu/understanding-solidity-assembly-hashing-a-string-from-calldata-fbd2ece82263
                    calldatacopy(ptr, add(68, cursor), msg_len)
                    digest := keccak256(ptr, msg_len)
		        }

                break;
            } else {
                for (uint256 chunkIdx = 0; chunkIdx < eventChunks[palletIndex][eventIndex].length; chunkIdx++) {
                    cursor += jumpOverChunkCalldata(palletIndex, eventIndex, chunkIdx, encodedEventsList[cursor:]);
                }
            }

            // There is a 0 value byte at the end of each event
            require(uint8(encodedEventsList[cursor]) == 0, "last byte of event is not 0");
            cursor += 1;
        }
    }

    /// @notice This function will "jump over" a chunk in the encoded event list.
    function jumpOverChunkCalldata(uint8 palletIndex, uint8 eventIndex, uint256 chunkIndex, bytes calldata encodedEventsList)
        internal
        view
        returns (uint256)
    {
        Chunk storage chunk = eventChunks[palletIndex][eventIndex][chunkIndex];
        uint256 bytesRead;
        if (chunk.chunkType == chunkType.CONSTANT_SIZE) {
            bytesRead += chunk.size;
        } else if (chunk.chunkType == chunkType.COMPACT) {
            (, uint256 uintByteLen) = ScaleCodec.decodeUintCompactCalldata(encodedEventsList[bytesRead:]);
            bytesRead += uintByteLen;
        } else if (chunk.chunkType == chunkType.SEQUENCE) {
            (uint256 numChunks, uint256 uintByteLen) = ScaleCodec.decodeUintCompactCalldata(encodedEventsList[bytesRead:]);
            bytesRead += uintByteLen;
            for (uint256 i = 0; i < numChunks; i++) {
                for (uint256 j = 0; j < chunk.sequenceChunks.length; j++) {
                    bytesRead += jumpOverChunkCalldata(palletIndex, eventIndex, chunkIndex, encodedEventsList[bytesRead:]);
                }
            }
        } else {
            revert("Unknown chunk type");
        }

        return bytesRead;
    }

    /// @notice This function will "jump over" a chunk in the encoded event list.
    function jumpOverChunk(Chunk memory chunk, ByteSlice memory encodedEventsListSlice) internal view {
        if (chunk.chunkType == chunkType.CONSTANT_SIZE) {
            encodedEventsListSlice.offset += chunk.size;
        } else if (chunk.chunkType == chunkType.COMPACT) {
            ScaleCodec.decodeUintCompact(encodedEventsListSlice);
        } else if (chunk.chunkType == chunkType.SEQUENCE) {
            uint256 numChunks = ScaleCodec.decodeUintCompact(encodedEventsListSlice);
            for (uint256 i = 0; i < numChunks; i++) {
                for (uint256 j = 0; j < chunk.sequenceChunks.length; j++) {
                    jumpOverChunk(chunk.sequenceChunks[j], encodedEventsListSlice);
                }
            }
        } else {
            revert("Unknown chunk type");
        }
    }

     /**
      * @notice Verifies substrate specific merkle patricia proofs.
      * @param root hash of the merkle patricia trie
      * @param proof a list of proof nodes
      * @param keys a list of keys to verify
      * @return bytes value corresponding to the supplied key.
      * @return bytes32 digest of the encoded event list
      */
    function VerifySubstrateProof(bytes32 root, bytes[] memory proof, bytes[] memory keys, bool decodeEventList)
        internal
        returns (bytes[] memory, bytes32)
    {
        bytes[] memory values = new bytes[](keys.length);
        TrieNode[] memory nodes = new TrieNode[](proof.length);

        for (uint256 i = 0; i < proof.length; i++) {
            nodes[i] = TrieNode(Bytes.toBytes32(Blake2b.blake2b(proof[i], 32)), proof[i]);
        }

        for (uint256 i = 0; i < keys.length; i++) {
            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);
            NodeKind memory node = SubstrateTrieDBOriginal.decodeNodeKind(TrieDB.get(nodes, root));

            // worst case scenario, so we avoid unbounded loops
            for (uint256 j = 0; j < 50; j++) {
                NodeHandle memory nextNode;

                if (TrieDB.isLeaf(node)) {
                    Leaf memory leaf = SubstrateTrieDBOriginal.decodeLeaf(node);
                    if (NibbleSliceOpsOriginal.eq(leaf.key, keyNibbles)) {
                        values[i] = TrieDB.load(nodes, leaf.value);
                    }
                    break;
                }  else if (TrieDB.isNibbledBranch(node)) {
                    NibbledBranch memory nibbled = SubstrateTrieDBOriginal.decodeNibbledBranch(node);
                    uint256 nibbledBranchKeyLength = NibbleSliceOpsOriginal.len(nibbled.key);
                    if (!NibbleSliceOpsOriginal.startsWith(keyNibbles, nibbled.key)) {
                        break;
                    }

                    if (NibbleSliceOpsOriginal.len(keyNibbles) == nibbledBranchKeyLength) {
                        if (Option.isSome(nibbled.value)) {
                            values[i] = TrieDB.load(nodes, nibbled.value.value);
                        }
                        break;
                    } else {
                        uint256 index = NibbleSliceOpsOriginal.at(keyNibbles, nibbledBranchKeyLength);
                        NodeHandleOption memory handle = nibbled.children[index];
                        if (Option.isSome(handle)) {
                            keyNibbles = NibbleSliceOpsOriginal.mid(keyNibbles, nibbledBranchKeyLength + 1);
                            nextNode = handle.value;
                        } else {
                            break;
                        }
                    }
                }  else if (TrieDB.isEmpty(node)) {
                    break;
                }

                node = SubstrateTrieDBOriginal.decodeNodeKind(TrieDB.load(nodes, nextNode));
            }
        }

        bytes32 digest;
        /*
        if (decodeEventList == true) {
            digest = decodeAuthoritySet(values[0]);
        }
        */

        return (values, digest);
    }

    struct ValueInfo {
        bytes32 nodeHash;
        uint256 start;
        uint256 len;
        bool found;
    }

    function extractChildren(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        SubstrateTrieDB.ChildNodeHandle[16] memory children,
        uint256 index,
        bytes calldata node
    )
        internal
    {
        uint256 childrenStart;
        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH) {
            (childrenStart, ) = SubstrateTrieDB.decodeNibbledBranch(children, node[nodeCursor.cursor:], nodeCursor);
            childrenStart += nodeCursor.cursor;
        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH) {
            (, childrenStart, ) = SubstrateTrieDB.decodeNibbledHashedValueBranch(children, node[nodeCursor.cursor:], nodeCursor);
            childrenStart += nodeCursor.cursor;
        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
            (, , childrenStart, ) = SubstrateTrieDB.decodeNibbledValueBranch(children, node[nodeCursor.cursor:], nodeCursor);
            childrenStart += nodeCursor.cursor;
        }

        if (!children[index].isEmpty) {
            if (children[index].isInline) {
                nodeCursor.cursor = childrenStart + children[index].inlineStart;
                nodeCursor.nodeHash = nodeCursor.nodeHash;
            } else {
                nodeCursor.nodeHash = children[index].digest;
                nodeCursor.cursor = 0;

                if (children[index].digest == 0xae414b798b4d311636287745034330a1e71c2fa06a03c249d14d86fb7d6e942c) {
                    nodeCursor.calldataStartAddress = 388;
                } else if (children[index].digest == 0x392e31be566cea43139373a9dbc60ac59faeca64e2d99a663ce19ae79e14d72b) {
                    nodeCursor.calldataStartAddress = 3652;
                } else if (children[index].digest == 0x174d296b2a5b2aca13d8b25eab3d206e041134a550f2fe802c67c8bc0b017a4d) {
                    nodeCursor.calldataStartAddress = 3748;
                } else if (children[index].digest == 0x0ed6846e8dc9b1835c06f995123a2b1ae2f74a61597cd032c20c5620c3a9c003) {
                    nodeCursor.calldataStartAddress = 3876;
                } else if (children[index].digest == 0xb237d8cc3098c339a59f782f9a02137cc98522ee3c7c49b73f2ff6120fabf4da) {
                    nodeCursor.calldataStartAddress = 4100;
                } else if (children[index].digest == 0xfc1f1fa639bef923233bbcd9fbcc86e565f52d33c5c19b238fccd26dd41c2bc3) {
                    nodeCursor.calldataStartAddress = 4612;
                }

            }
        } else {
            revert("Key not found in proof");
        }
    }

    function extractValue(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        ValueInfo memory valueInfo,
        SubstrateTrieDB.ChildNodeHandle[16] memory children,
        bytes calldata node
    ) 
        internal
    {
        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.LEAF) {
            // Get the size of the value
            (valueInfo.len, ) = ScaleCodec.decodeUintCompactCalldata(node[nodeCursor.cursor:]);
            valueInfo.start = nodeCursor.cursor;
            valueInfo.nodeHash = nodeCursor.nodeHash;
            valueInfo.found = true;

        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.HASHED_LEAF) {
            valueInfo.nodeHash = Bytes.toBytes32Calldata(nodeCursor.calldataStartAddress + nodeCursor.cursor);
            valueInfo.start = 0;
            valueInfo.len = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
            valueInfo.found = true;
        } else if (
            nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH ||
            nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {

            if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH) {
                (valueInfo.nodeHash, , ) = SubstrateTrieDB.decodeNibbledHashedValueBranch(children, node[nodeCursor.cursor:], nodeCursor);
                valueInfo.start = 0;
                valueInfo.len = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
                valueInfo.found = true;
            } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
                uint256 nodeValueStart;
                uint256 nodeValueLen;
                (nodeValueStart, nodeValueLen, , ) = SubstrateTrieDB.decodeNibbledValueBranch(children, node[nodeCursor.cursor:], nodeCursor);
                valueInfo.nodeHash = nodeCursor.nodeHash;
                valueInfo.start = nodeValueStart;
                valueInfo.len = nodeValueLen;
                valueInfo.found = true;
            }
        }
    }

    function processNode(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        ValueInfo memory valueInfo,
        SubstrateTrieDB.ChildNodeHandle[16] memory children,
        uint256 keyNibbleCursor,
        bytes calldata node,
        bytes calldata key
    )
        internal
        returns (
            uint256 updatedKeyNibbleCursor
        )
    {
        uint256 bytesRead;
        uint256 nibbleSize;
        (nodeCursor.nodeType, nibbleSize, bytesRead) = SubstrateTrieDB.decodeNodeKind(node[nodeCursor.cursor:]);
        nodeCursor.cursor += bytesRead;

        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.EMPTY) {
            revert("Empty node found in proof");
        }

        // Get the key nibble from the node
        uint256 commonKeyPrefixLen = 0;
        if (nibbleSize > 0) {
            bytesRead = SubstrateTrieDB.decodeKey(node[nodeCursor.cursor:], nibbleSize);
            commonKeyPrefixLen = NibbleSliceOpsCalldata.commonPrefix(
                key, keyNibbleCursor, key.length * 2,
                node[nodeCursor.cursor:], nibbleSize % SubstrateTrieDB.NIBBLE_PER_BYTE, nibbleSize);
            nodeCursor.cursor += bytesRead;
        }

        bool keyNibbleFullMatch = (commonKeyPrefixLen == key.length * 2 - keyNibbleCursor);
        if (keyNibbleFullMatch) {
            if (!(nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH)) {
                extractValue(
                    nodeCursor,
                    valueInfo,
                    children,
                    node
                );
            } else {
                revert("Key not found in proof");
            }
        } else {
            if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH ||
                nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH ||
                nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
                    uint256 at = keyNibbleCursor + nibbleSize;
                    uint256 index = NibbleSliceOpsCalldata.at(key, at);
                    extractChildren(
                        nodeCursor,
                        children,
                        index,
                        node
                    );
            } else {
                revert("Key not found in proof");
            }
        }

        if (!valueInfo.found) {
            // Increment the key
            updatedKeyNibbleCursor = keyNibbleCursor + (nibbleSize + 1);
        }
    }

     /**
      * @notice Verifies substrate specific merkle patricia proofs.
      * @param root hash of the merkle patricia trie
      * @param proof a list of proof nodes
      * @param key a key to verify
      * @return bytes[] a list of values corresponding to the supplied keys.
      */
    function VerifySubstrateProofCalldata
    (
        bytes[] calldata proof,
        bytes calldata key,
        bytes32 root,
        bool authEventListPostProcess
    )
        internal
        returns (uint64, bytes32)
    {
        bytes32[] memory trieNodeHashes = new bytes32[](proof.length);

        /*
        bytes32 zero;
        bytes32 one;
        bytes32 two;
        bytes32 three;
        bytes32 four;
        assembly {
            zero := calldataload(4580)
            one := calldataload(4612)
            two := calldataload(4644)
            three := calldataload(4676)
            four := calldataload(4708)
        }
        console.logBytes32(zero);
        console.logBytes32(one);
        console.logBytes32(two);
        console.logBytes32(three);
        console.logBytes32(four);
        */

        uint256 i;
        for (i = 0; i < proof.length; i++) {
            // TODO:  Make blake2b work with calldata
            bytes32 nodeDigest = Bytes.toBytes32(Blake2b.blake2b(proof[i], 32));
            trieNodeHashes[i] = nodeDigest;
        }

        uint256 keyNibbleCursor = 0;

        // Start with looking up the node that maps to the root hash
        SubstrateTrieDB.NodeCursor memory currentNodeCursor;
        currentNodeCursor.nodeHash = root;
        currentNodeCursor.cursor = 0;
        currentNodeCursor.calldataStartAddress = 4100;

        ValueInfo memory valueInfo;
        SubstrateTrieDB.ChildNodeHandle[16] memory children;
        for (i = 0; i < MAX_NUM_PROOF_NODES; i++) {
            keyNibbleCursor = processNode(
                currentNodeCursor,
                valueInfo,
                children,
                keyNibbleCursor,
                proof[TrieNodeLookup(trieNodeHashes, currentNodeCursor.nodeHash)],
                key
            );

            if (valueInfo.found) {
                if (valueInfo.len == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {  // This means that the value info length needs to be filled
                    valueInfo.len = proof[TrieNodeLookup(trieNodeHashes, valueInfo.nodeHash)].length;
                    break;
                }
            }
        }

        /*
        // If the key is for the authority event list, then decode it and hash the result
        // If the key is for the authority set id, then decode it to a uint64
        bytes32 authoritySetDigest;
        uint64 authoritySetId;
        if (authEventListPostProcess) {
            authoritySetDigest = decodeAuthoritySetCalldata(proof[TrieNodeLookup(trieNodeHashes, valueInfo.nodeHash)][valueInfo.start:valueInfo.start + valueInfo.len]);
        } else {
            authoritySetId = ScaleCodec.decodeUint64(proof[TrieNodeLookup(trieNodeHashes, valueInfo.nodeHash)][valueInfo.start:valueInfo.start + valueInfo.len]);
        }
        */

        bytes32 authoritySetDigest;
        uint64 authoritySetId;

        return (authoritySetId, authoritySetDigest);
    }

    function TrieNodeLookup(bytes32[] memory trieNodeDigests, bytes32 hash)
        internal
        pure
        returns (uint256 i)
    {
        for (i = 0; i < trieNodeDigests.length; i++) {
            if (trieNodeDigests[i]== hash) {
                return i;
            }
        }
        revert("TrieNodeLookup failed");
    }
}
