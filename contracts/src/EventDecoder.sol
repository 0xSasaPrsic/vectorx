pragma solidity 0.8.17;

import { Memory } from "solidity-merkle-trees/src/trie/Memory.sol";
import { ByteSlice, Bytes } from "solidity-merkle-trees/src/trie/Bytes.sol";
import { ScaleCodec } from "solidity-merkle-trees/src/trie/substrate/ScaleCodec.sol";
import { KEY_ADDRESS, KEY_BYTE_LENGTH,
         MAX_NUM_PROOF_NODES, NUM_AUTHORITIES, NUM_CHILDREN,
         PROOF_ARRAY_LEN_ADDRESS, PROOF_ELEMENT_START_ADDRESS_ADDRESS, PROOF_ELEMENT_START_ADDRESS_OFFSET } from "src/Constants.sol";
import "src/SubstrateTrieDB.sol";
import "src/NibbleSlice.sol";

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "solidity-merkle-trees/src/trie/Bytes.sol";
import "solidity-merkle-trees/src/trie/Node.sol";
import { NibbleSliceOps as NibbleSliceOpsOriginal } from "solidity-merkle-trees/src/trie/NibbleSlice.sol";


import "solidity-merkle-trees/src/trie/Option.sol";
import "solidity-merkle-trees/src/trie/TrieDB.sol";

import "solidity-merkle-trees/src/trie/substrate/Blake2b.sol";
import { SubstrateTrieDB as SubstrateTrieDBOriginal } from "solidity-merkle-trees/src/trie/substrate/SubstrateTrieDB.sol";


/// @title Event Scale Decoder
/// @author Succinct Labs
/// @notice This function is used to scale decode events.
contract EventDecoder {
    enum chunkType{ CONSTANT_SIZE, COMPACT, SEQUENCE }

    struct Chunk {
        chunkType chunkType;
        uint32 size;
        Chunk[] sequenceChunks;
    }

    mapping(uint8 => mapping(uint8 => Chunk[])) eventChunks;

    /// @notice This function is generated by the program utils/gen_avail_event_types.rs
    constructor() {
        eventChunks[0][0].push();
        eventChunks[0][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][0][0].size = 4;
        eventChunks[0][0].push();
        eventChunks[0][0][1].chunkType = chunkType.COMPACT;
        eventChunks[0][0].push();
        eventChunks[0][0][2].chunkType = chunkType.COMPACT;
        eventChunks[0][0].push();
        eventChunks[0][0][3].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][0][3].size = 2;
        eventChunks[0][1].push();
        eventChunks[0][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][1][0].size = 15;
        eventChunks[0][3].push();
        eventChunks[0][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][3][0].size = 32;
        eventChunks[0][4].push();
        eventChunks[0][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][4][0].size = 32;
        eventChunks[0][5].push();
        eventChunks[0][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[0][5][0].size = 64;
        eventChunks[1][0].push();
        eventChunks[1][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[1][0][0].size = 9;
        eventChunks[1][3].push();
        eventChunks[1][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[1][3][0].size = 6;
        eventChunks[5][0].push();
        eventChunks[5][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][0][0].size = 36;
        eventChunks[5][1].push();
        eventChunks[5][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][1][0].size = 4;
        eventChunks[5][2].push();
        eventChunks[5][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[5][2][0].size = 36;
        eventChunks[6][0].push();
        eventChunks[6][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][0][0].size = 48;
        eventChunks[6][1].push();
        eventChunks[6][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][1][0].size = 48;
        eventChunks[6][2].push();
        eventChunks[6][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][2][0].size = 80;
        eventChunks[6][3].push();
        eventChunks[6][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][3][0].size = 64;
        eventChunks[6][4].push();
        eventChunks[6][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][4][0].size = 48;
        eventChunks[6][5].push();
        eventChunks[6][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][5][0].size = 48;
        eventChunks[6][6].push();
        eventChunks[6][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][6][0].size = 81;
        eventChunks[6][7].push();
        eventChunks[6][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][7][0].size = 48;
        eventChunks[6][8].push();
        eventChunks[6][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][8][0].size = 48;
        eventChunks[6][9].push();
        eventChunks[6][9][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[6][9][0].size = 48;
        eventChunks[9][0].push();
        eventChunks[9][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][0][0].size = 2;
        eventChunks[9][1].push();
        eventChunks[9][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][1][0].size = 2;
        eventChunks[9][2].push();
        eventChunks[9][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][2][0].size = 48;
        eventChunks[9][3].push();
        eventChunks[9][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][3][0].size = 48;
        eventChunks[9][4].push();
        eventChunks[9][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][4][0].size = 4;
        eventChunks[9][5].push();
        eventChunks[9][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[9][5][0].size = 4;
        eventChunks[10][0].push();
        eventChunks[10][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][0][0].size = 36;
        eventChunks[10][1].push();
        eventChunks[10][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][1][0].size = 48;
        eventChunks[10][2].push();
        eventChunks[10][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][2][0].size = 48;
        eventChunks[10][3].push();
        eventChunks[10][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][3][0].size = 4;
        eventChunks[10][5].push();
        eventChunks[10][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][5][0].size = 48;
        eventChunks[10][6].push();
        eventChunks[10][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][6][0].size = 48;
        eventChunks[10][7].push();
        eventChunks[10][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][7][0].size = 48;
        eventChunks[10][8].push();
        eventChunks[10][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][8][0].size = 64;
        eventChunks[10][10].push();
        eventChunks[10][10][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][10][0].size = 32;
        eventChunks[10][11].push();
        eventChunks[10][11][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[10][11][0].size = 36;
        eventChunks[11][0].push();
        eventChunks[11][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[11][0][0].size = 4;
        eventChunks[12][0].push();
        eventChunks[12][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][0][0].size = 20;
        eventChunks[12][1].push();
        eventChunks[12][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][1][0].size = 20;
        eventChunks[12][1].push();
        eventChunks[12][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[12][1][1].sequenceChunks.push();
        eventChunks[12][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][1][1].sequenceChunks[0].size = 32;
        eventChunks[12][3].push();
        eventChunks[12][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][3][0].size = 5;
        eventChunks[12][4].push();
        eventChunks[12][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][4][0].size = 4;
        eventChunks[12][5].push();
        eventChunks[12][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][5][0].size = 4;
        eventChunks[12][6].push();
        eventChunks[12][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][6][0].size = 4;
        eventChunks[12][7].push();
        eventChunks[12][7][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][7][0].size = 10;
        eventChunks[12][8].push();
        eventChunks[12][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][8][0].size = 64;
        eventChunks[12][9].push();
        eventChunks[12][9][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][9][0].size = 32;
        eventChunks[12][10].push();
        eventChunks[12][10][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][10][0].size = 68;
        eventChunks[12][11].push();
        eventChunks[12][11][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][11][0].size = 80;
        eventChunks[12][12].push();
        eventChunks[12][12][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][12][0].size = 80;
        eventChunks[12][13].push();
        eventChunks[12][13][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][13][0].size = 36;
        eventChunks[12][14].push();
        eventChunks[12][14][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][14][0].size = 36;
        eventChunks[12][15].push();
        eventChunks[12][15][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][15][0].size = 112;
        eventChunks[12][16].push();
        eventChunks[12][16][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[12][16][0].size = 32;
        eventChunks[13][0].push();
        eventChunks[13][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][0][0].size = 72;
        eventChunks[13][1].push();
        eventChunks[13][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][1][0].size = 73;
        eventChunks[13][2].push();
        eventChunks[13][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][2][0].size = 32;
        eventChunks[13][3].push();
        eventChunks[13][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][3][0].size = 32;
        eventChunks[13][4].push();
        eventChunks[13][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][4][0].size = 38;
        eventChunks[13][5].push();
        eventChunks[13][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][5][0].size = 38;
        eventChunks[13][6].push();
        eventChunks[13][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[13][6][0].size = 40;
        eventChunks[14][0].push();
        eventChunks[14][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][0][0].size = 72;
        eventChunks[14][1].push();
        eventChunks[14][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][1][0].size = 73;
        eventChunks[14][2].push();
        eventChunks[14][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][2][0].size = 32;
        eventChunks[14][3].push();
        eventChunks[14][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][3][0].size = 32;
        eventChunks[14][4].push();
        eventChunks[14][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][4][0].size = 38;
        eventChunks[14][5].push();
        eventChunks[14][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][5][0].size = 38;
        eventChunks[14][6].push();
        eventChunks[14][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[14][6][0].size = 40;
        eventChunks[15][0].push();
        eventChunks[15][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[15][0][0].sequenceChunks.push();
        eventChunks[15][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][0][0].sequenceChunks[0].size = 48;
        eventChunks[15][3].push();
        eventChunks[15][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][3][0].size = 32;
        eventChunks[15][4].push();
        eventChunks[15][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][4][0].size = 32;
        eventChunks[15][5].push();
        eventChunks[15][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][5][0].size = 48;
        eventChunks[15][6].push();
        eventChunks[15][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[15][6][0].size = 48;
        eventChunks[17][0].push();
        eventChunks[17][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[17][0][0].sequenceChunks.push();
        eventChunks[17][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[17][0][0].sequenceChunks[0].size = 40;
        eventChunks[18][0].push();
        eventChunks[18][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][0][0].size = 4;
        eventChunks[18][1].push();
        eventChunks[18][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][1][0].size = 16;
        eventChunks[18][2].push();
        eventChunks[18][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][2][0].size = 52;
        eventChunks[18][3].push();
        eventChunks[18][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][3][0].size = 20;
        eventChunks[18][4].push();
        eventChunks[18][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][4][0].size = 16;
        eventChunks[18][5].push();
        eventChunks[18][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][5][0].size = 16;
        eventChunks[18][6].push();
        eventChunks[18][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][6][0].size = 16;
        eventChunks[18][8].push();
        eventChunks[18][8][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[18][8][0].size = 32;
        eventChunks[19][0].push();
        eventChunks[19][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][0][0].size = 6;
        eventChunks[19][1].push();
        eventChunks[19][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][1][0].size = 32;
        eventChunks[19][2].push();
        eventChunks[19][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[19][2][0].size = 6;
        eventChunks[20][0].push();
        eventChunks[20][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][0][0].size = 32;
        eventChunks[20][2].push();
        eventChunks[20][2][0].chunkType = chunkType.SEQUENCE;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][2][0].sequenceChunks[0].size = 32;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[1].chunkType = chunkType.COMPACT;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[2].chunkType = chunkType.COMPACT;
        eventChunks[20][2][0].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].chunkType = chunkType.SEQUENCE;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[0].size = 32;
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks.push();
        eventChunks[20][2][0].sequenceChunks[3].sequenceChunks[1].chunkType = chunkType.COMPACT;
        eventChunks[22][0].push();
        eventChunks[22][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[22][0][0].size = 16;
        eventChunks[22][0].push();
        eventChunks[22][0][1].chunkType = chunkType.SEQUENCE;
        eventChunks[22][0][1].sequenceChunks.push();
        eventChunks[22][0][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[22][0][1].sequenceChunks[0].size = 1;
        eventChunks[24][0].push();
        eventChunks[24][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][0][0].size = 8;
        eventChunks[24][1].push();
        eventChunks[24][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][1][0].size = 8;
        eventChunks[24][2].push();
        eventChunks[24][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][0].size = 9;
        eventChunks[24][2].push();
        eventChunks[24][2][1].chunkType = chunkType.SEQUENCE;
        eventChunks[24][2][1].sequenceChunks.push();
        eventChunks[24][2][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][1].sequenceChunks[0].size = 1;
        eventChunks[24][2].push();
        eventChunks[24][2][2].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[24][2][2].size = 6;
        eventChunks[25][0].push();
        eventChunks[25][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][0][0].size = 4;
        eventChunks[25][1].push();
        eventChunks[25][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][1][0].size = 20;
        eventChunks[25][2].push();
        eventChunks[25][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][2][0].size = 4;
        eventChunks[25][3].push();
        eventChunks[25][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][3][0].size = 36;
        eventChunks[25][4].push();
        eventChunks[25][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][4][0].size = 52;
        eventChunks[25][5].push();
        eventChunks[25][5][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][5][0].size = 4;
        eventChunks[25][6].push();
        eventChunks[25][6][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[25][6][0].size = 4;
        eventChunks[26][0].push();
        eventChunks[26][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][0][0].size = 32;
        eventChunks[26][1].push();
        eventChunks[26][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][1][0].size = 32;
        eventChunks[26][2].push();
        eventChunks[26][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][2][0].size = 80;
        eventChunks[26][3].push();
        eventChunks[26][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][3][0].size = 32;
        eventChunks[26][4].push();
        eventChunks[26][4][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[26][4][0].size = 80;
        eventChunks[28][0].push();
        eventChunks[28][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[28][0][0].size = 48;
        eventChunks[29][0].push();
        eventChunks[29][0][0].chunkType = chunkType.SEQUENCE;
        eventChunks[29][0][0].sequenceChunks.push();
        eventChunks[29][0][0].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][0][0].sequenceChunks[0].size = 1;
        eventChunks[29][0].push();
        eventChunks[29][0][1].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][0][1].size = 32;
        eventChunks[29][0].push();
        eventChunks[29][0][2].chunkType = chunkType.COMPACT;
        eventChunks[29][1].push();
        eventChunks[29][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][1][0].size = 32;
        eventChunks[29][1].push();
        eventChunks[29][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[29][1][1].sequenceChunks.push();
        eventChunks[29][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][1][1].sequenceChunks[0].size = 1;
        eventChunks[29][2].push();
        eventChunks[29][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[29][2][0].size = 8;
        eventChunks[30][0].push();
        eventChunks[30][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[30][0][0].size = 40;
        eventChunks[30][1].push();
        eventChunks[30][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[30][1][0].size = 32;
        eventChunks[31][0].push();
        eventChunks[31][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][0][0].size = 76;
        eventChunks[31][0].push();
        eventChunks[31][0][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][0][1].sequenceChunks.push();
        eventChunks[31][0][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][0][1].sequenceChunks[0].size = 1;
        eventChunks[31][1].push();
        eventChunks[31][1][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][1][0].size = 68;
        eventChunks[31][1].push();
        eventChunks[31][1][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][1][1].sequenceChunks.push();
        eventChunks[31][1][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][1][1].sequenceChunks[0].size = 1;
        eventChunks[31][2].push();
        eventChunks[31][2][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][2][0].size = 64;
        eventChunks[31][2].push();
        eventChunks[31][2][1].chunkType = chunkType.SEQUENCE;
        eventChunks[31][2][1].sequenceChunks.push();
        eventChunks[31][2][1].sequenceChunks[0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][2][1].sequenceChunks[0].size = 1;
        eventChunks[31][3].push();
        eventChunks[31][3][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[31][3][0].size = 52;
        eventChunks[32][0].push();
        eventChunks[32][0][0].chunkType = chunkType.CONSTANT_SIZE;
        eventChunks[32][0][0].size = 72;
    }

    /// @notice This function will decode the authority set from the encoded event list
    function decodeAuthoritySet(bytes memory encodedEventList) internal returns (bytes32 digest) {
        ByteSlice memory encodedEventsListSlice = ByteSlice(encodedEventList, 0);

        // First get the length of the encoded_events_list
        uint256 num_events = ScaleCodec.decodeUintCompact(encodedEventsListSlice);

        uint8 phase;
        uint8 palletIndex;
        uint8 eventIndex;

        // Parse the scale encoded events
        for (uint256 i = 0; i < num_events; i++) {
            // First element is the Phase enum value (0 - ApplyExtrinsic, 1 - Finalization, 2 - Initialization)
            phase = Bytes.readByte(encodedEventsListSlice);

            // Second element is the pallet_index
            palletIndex = Bytes.readByte(encodedEventsListSlice);

            // Third element is the event_index
            eventIndex = Bytes.readByte(encodedEventsListSlice);

            // Decode the actual event
            if (phase == 1 && palletIndex == 17 && eventIndex == 0) {
                // This is the NewAuthorities event

                // The next element is the length of the encoded new authorities list
                uint256 numAuthorities = ScaleCodec.decodeUintCompact(encodedEventsListSlice);
                if (numAuthorities != NUM_AUTHORITIES) {
                    revert("Incorrect number of authorities");
                }

                (uint srcAddr,) = Memory.fromBytes(encodedEventsListSlice.data);
                srcAddr += encodedEventsListSlice.offset;
                uint256 msg_len = numAuthorities * 40;

                assembly {
                    digest := keccak256(srcAddr, msg_len)
                }

                break;
            } else {
                for (uint256 chunkIdx = 0; chunkIdx < eventChunks[palletIndex][eventIndex].length; chunkIdx++) {
                    jumpOverChunk(eventChunks[palletIndex][eventIndex][chunkIdx], encodedEventsListSlice);
                }
            }

            // There is a 0 value byte at the end of each event
            require(Bytes.readByte(encodedEventsListSlice) == 0, "last byte of event is not 0");
        }
    }

    /// @notice This function will decode the authority set from the encoded event list
    function decodeAuthoritySetCalldata(ValueInfo memory valueInfo) internal returns (bytes32 digest) {
        uint256 startCursor = valueInfo.cursor;

        uint256 num_events;
        uint256 bytesRead;
        // First get the length of the encoded_events_list
        (num_events, bytesRead) = ScaleCodec.decodeUintCompactCalldata(valueInfo.cursor);
        valueInfo.cursor += bytesRead;

        uint8 phase;
        uint8 palletIndex;
        uint8 eventIndex;

        // Parse the scale encoded events
        for (uint256 i = 0; i < num_events; i++) {
            // First element is the Phase enum value (0 - ApplyExtrinsic, 1 - Finalization, 2 - Initialization)
            phase = ScaleCodec.decodeUint8Calldata(valueInfo.cursor);
            valueInfo.cursor += 1;

            // Second element is the pallet_index
            palletIndex = ScaleCodec.decodeUint8Calldata(valueInfo.cursor);
            valueInfo.cursor += 1;

            // Third element is the event_index
            eventIndex = ScaleCodec.decodeUint8Calldata(valueInfo.cursor);
            valueInfo.cursor += 1;

            // Decode the actual event
            if (phase == 1 && palletIndex == 17 && eventIndex == 0) {
                // This is the NewAuthorities event

                // The next element is the length of the encoded new authorities list
                uint256 numAuthorities;
                (numAuthorities, bytesRead) = ScaleCodec.decodeUintCompactCalldata(valueInfo.cursor);
                valueInfo.cursor += bytesRead;
                if (numAuthorities != NUM_AUTHORITIES) {
                    revert("Incorrect number of authorities");
                }

                uint256 cursor = valueInfo.cursor;
                assembly {
                    let ptr := mload(0x40)
                    let msg_len := mul(numAuthorities, 40)
                    calldatacopy(ptr, cursor, msg_len)
                    digest := keccak256(ptr, msg_len)
		        }

                break;
            } else {
                for (uint256 chunkIdx = 0; chunkIdx < eventChunks[palletIndex][eventIndex].length; chunkIdx++) {
                    jumpOverChunkCalldata(palletIndex, eventIndex, chunkIdx, valueInfo);
                }
            }

            // There is a 0 value byte at the end of each event
            require(ScaleCodec.decodeUint8Calldata(valueInfo.cursor) == 0, "last byte of event is not 0");
            valueInfo.cursor += 1;
        }

        // We may have exited the decoding early if we encountered the encoded events list early.
        if ((valueInfo.cursor - startCursor) > valueInfo.len) {
            revert("Invalid encoded event list");
        }
    }

    /// @notice This function will "jump over" a chunk in the encoded event list.
    function jumpOverChunkCalldata(uint8 palletIndex, uint8 eventIndex, uint256 chunkIndex, ValueInfo memory valueInfo)
        internal
        view
    {
        Chunk storage chunk = eventChunks[palletIndex][eventIndex][chunkIndex];
        if (chunk.chunkType == chunkType.CONSTANT_SIZE) {
            valueInfo.cursor += chunk.size;
        } else if (chunk.chunkType == chunkType.COMPACT) {
            (, uint256 uintByteLen) = ScaleCodec.decodeUintCompactCalldata(valueInfo.cursor);
            valueInfo.cursor += uintByteLen;
        } else if (chunk.chunkType == chunkType.SEQUENCE) {
            (uint256 numChunks, uint256 uintByteLen) = ScaleCodec.decodeUintCompactCalldata(valueInfo.cursor);
            valueInfo.cursor += uintByteLen;
            for (uint256 i = 0; i < numChunks; i++) {
                for (uint256 j = 0; j < chunk.sequenceChunks.length; j++) {
                    jumpOverChunkCalldata(palletIndex, eventIndex, chunkIndex, valueInfo);
                }
            }
        } else {
            revert("Unknown chunk type");
        }
    }

    /// @notice This function will "jump over" a chunk in the encoded event list.
    function jumpOverChunk(Chunk memory chunk, ByteSlice memory encodedEventsListSlice) internal view {
        if (chunk.chunkType == chunkType.CONSTANT_SIZE) {
            encodedEventsListSlice.offset += chunk.size;
        } else if (chunk.chunkType == chunkType.COMPACT) {
            ScaleCodec.decodeUintCompact(encodedEventsListSlice);
        } else if (chunk.chunkType == chunkType.SEQUENCE) {
            uint256 numChunks = ScaleCodec.decodeUintCompact(encodedEventsListSlice);
            for (uint256 i = 0; i < numChunks; i++) {
                for (uint256 j = 0; j < chunk.sequenceChunks.length; j++) {
                    jumpOverChunk(chunk.sequenceChunks[j], encodedEventsListSlice);
                }
            }
        } else {
            revert("Unknown chunk type");
        }
    }

     /**
      * @notice Verifies substrate specific merkle patricia proofs.
      * @param root hash of the merkle patricia trie
      * @param proof a list of proof nodes
      * @param keys a list of keys to verify
      * @return bytes value corresponding to the supplied key.
      * @return bytes32 digest of the encoded event list
      */
    function VerifySubstrateProof(bytes32 root, bytes[] memory proof, bytes[] memory keys, bool decodeEventList)
        internal
        returns (bytes[] memory, bytes32)
    {
        bytes[] memory values = new bytes[](keys.length);
        TrieNode[] memory nodes = new TrieNode[](proof.length);

        for (uint256 i = 0; i < proof.length; i++) {
            nodes[i] = TrieNode(Bytes.toBytes32(Blake2b.blake2b(proof[i], 32)), proof[i]);
        }

        for (uint256 i = 0; i < keys.length; i++) {
            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);
            NodeKind memory node = SubstrateTrieDBOriginal.decodeNodeKind(TrieDB.get(nodes, root));

            // worst case scenario, so we avoid unbounded loops
            for (uint256 j = 0; j < 50; j++) {
                NodeHandle memory nextNode;

                if (TrieDB.isLeaf(node)) {
                    Leaf memory leaf = SubstrateTrieDBOriginal.decodeLeaf(node);
                    if (NibbleSliceOpsOriginal.eq(leaf.key, keyNibbles)) {
                        values[i] = TrieDB.load(nodes, leaf.value);
                    }
                    break;
                }  else if (TrieDB.isNibbledBranch(node)) {
                    NibbledBranch memory nibbled = SubstrateTrieDBOriginal.decodeNibbledBranch(node);
                    uint256 nibbledBranchKeyLength = NibbleSliceOpsOriginal.len(nibbled.key);
                    if (!NibbleSliceOpsOriginal.startsWith(keyNibbles, nibbled.key)) {
                        break;
                    }

                    if (NibbleSliceOpsOriginal.len(keyNibbles) == nibbledBranchKeyLength) {
                        if (Option.isSome(nibbled.value)) {
                            values[i] = TrieDB.load(nodes, nibbled.value.value);
                        }
                        break;
                    } else {
                        uint256 index = NibbleSliceOpsOriginal.at(keyNibbles, nibbledBranchKeyLength);
                        NodeHandleOption memory handle = nibbled.children[index];
                        if (Option.isSome(handle)) {
                            keyNibbles = NibbleSliceOpsOriginal.mid(keyNibbles, nibbledBranchKeyLength + 1);
                            nextNode = handle.value;
                        } else {
                            break;
                        }
                    }
                }  else if (TrieDB.isEmpty(node)) {
                    break;
                }

                node = SubstrateTrieDBOriginal.decodeNodeKind(TrieDB.load(nodes, nextNode));
            }
        }

        bytes32 digest;
        if (decodeEventList == true) {
            digest = decodeAuthoritySet(values[0]);
        }

        return (values, digest);
    }

    struct ValueInfo {
        uint256 cursor;
        uint256 len;
        bool found;
    }

    function extractChildren(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        SubstrateTrieDB.ChildNodeHandle[NUM_CHILDREN] memory children,
        ProofCalldataInfo[] memory proofCalldataInfo,
        uint256 index
    )
        internal
    {
        uint256 childrenStart;
        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH) {
            childrenStart = SubstrateTrieDB.decodeNibbledBranch(children, nodeCursor);
        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH) {
            (, childrenStart) = SubstrateTrieDB.decodeNibbledHashedValueBranch(children, nodeCursor);
        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
            (, , childrenStart) = SubstrateTrieDB.decodeNibbledValueBranch(children, nodeCursor);
        }

        if (!children[index].isEmpty) {
            if (children[index].isInline) {
                nodeCursor.cursor = children[index].inlineStart;
            } else {
                nodeCursor.nodeHash = children[index].digest;
                uint256 idx = TrieNodeLookup(proofCalldataInfo, nodeCursor.nodeHash);
                nodeCursor.cursor = proofCalldataInfo[idx].calldataAddress;
            }
        } else {
            revert("Key not found in proof");
        }
    }

    function extractValue(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        ValueInfo memory valueInfo,
        SubstrateTrieDB.ChildNodeHandle[NUM_CHILDREN] memory children,
        ProofCalldataInfo[] memory proofCalldataInfo
    ) 
        internal
    {
        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.LEAF) {
            // Get the size of the value
            uint256 bytesRead;
            (valueInfo.len, bytesRead) = ScaleCodec.decodeUintCompactCalldata(nodeCursor.cursor);
            valueInfo.cursor = nodeCursor.cursor + bytesRead;
            valueInfo.found = true;

        } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.HASHED_LEAF) {
            bytes32 nodeHash = Bytes.toBytes32Calldata(nodeCursor.cursor);
            uint256 idx = TrieNodeLookup(proofCalldataInfo, nodeHash);
            valueInfo.cursor = proofCalldataInfo[idx].calldataAddress;
            valueInfo.len = proofCalldataInfo[idx].len;
            valueInfo.found = true;

        } else if (
            nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH ||
            nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {

            if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH) {
                (bytes32 nodeHash, ) = SubstrateTrieDB.decodeNibbledHashedValueBranch(children, nodeCursor);
                uint256 idx = TrieNodeLookup(proofCalldataInfo, nodeHash);
                valueInfo.cursor = proofCalldataInfo[idx].calldataAddress;
                valueInfo.len = proofCalldataInfo[idx].len;
                valueInfo.found = true;

            } else if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
                uint256 nodeValueStart;
                uint256 nodeValueLen;
                (nodeValueStart, nodeValueLen, ) = SubstrateTrieDB.decodeNibbledValueBranch(children, nodeCursor);
                valueInfo.cursor = nodeValueStart;
                valueInfo.len = nodeValueLen;
                valueInfo.found = true;
            }
        }
    }

    function processNode(
        SubstrateTrieDB.NodeCursor memory nodeCursor,
        ValueInfo memory valueInfo,
        SubstrateTrieDB.ChildNodeHandle[NUM_CHILDREN] memory children,
        ProofCalldataInfo[] memory proofCalldataInfo,
        uint256 keyNibbleCursor,
        uint256 keyAddress
    )
        internal
        returns (uint256 updatedKeyNibbleCursor)
    {
        uint256 bytesRead;
        uint256 nibbleSize;
        nibbleSize = SubstrateTrieDB.decodeNodeKind(nodeCursor);

        if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.EMPTY) {
            revert("Empty node found in proof");
        }

        // Get the key nibble from the node
        uint256 commonKeyPrefixLen = 0;
        if (nibbleSize > 0) {
            uint256 nibbleByteLen = SubstrateTrieDB.decodeKey(nodeCursor, nibbleSize);
            commonKeyPrefixLen = NibbleSliceOpsCalldata.commonPrefix(
                keyAddress, keyNibbleCursor, KEY_BYTE_LENGTH * 2,
                nodeCursor, nibbleSize % SubstrateTrieDB.NIBBLE_PER_BYTE, nibbleSize);
            nodeCursor.cursor += nibbleByteLen;
        }

        bool keyNibbleFullMatch = (commonKeyPrefixLen == KEY_BYTE_LENGTH * 2 - keyNibbleCursor);
        if (keyNibbleFullMatch) {
            if (!(nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH)) {
                extractValue(
                    nodeCursor,
                    valueInfo,
                    children,
                    proofCalldataInfo
                );
            } else {
                revert("Key not found in proof");
            }
        } else {
            if (nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_BRANCH ||
                nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_HASHED_VALUE_BRANCH ||
                nodeCursor.nodeType == SubstrateTrieDB.NodeType.NIBBLED_VALUE_BRANCH) {
                    uint256 at = keyNibbleCursor + nibbleSize;
                    uint256 index = NibbleSliceOpsCalldata.at(keyAddress, at);
                    extractChildren(
                        nodeCursor,
                        children,
                        proofCalldataInfo,
                        index
                    );
            } else {
                revert("Key not found in proof");
            }
        }

        if (!valueInfo.found) {
            // Increment the key
            updatedKeyNibbleCursor = keyNibbleCursor + (nibbleSize + 1);
        }
    }

    struct ProofCalldataInfo {
        uint256 calldataAddress;
        uint256 len;
        bytes32 digest;
    }

     /**
      * @notice Verifies substrate specific merkle patricia proofs.
      * @param root hash of the merkle patricia trie
      * @param proof a list of proof nodes
      * @param key a key to verify
      * @return bytes[] a list of values corresponding to the supplied keys.
      */
    function VerifySubstrateProofCalldata
    (
        bytes[] calldata proof,
        bytes calldata key,
        bytes32 root,
        bool authEventListPostProcess
    )
        internal
        returns (uint64, bytes32)
    {
        // First load the calldata addresses for the proof elements.
        // See the comment in Constants.sol for an example of the calldata layout.
        uint256 keyAddress;
        uint256 keyNibbleCursor;

        uint256 proofLen;
        bytes32 proofStartAddress;
        assembly {
            // Load the calldata address of key
            // Adding by 36, since there are 4 bytes for the function signature and 
            // then 32 bytes for the proof parameter address (which is already hard coded).
            keyAddress := add(calldataload(KEY_ADDRESS), 36)

            proofStartAddress := calldataload(4)
            proofStartAddress := add(proofStartAddress, 4)

            // Load the calldata address of proof
            proofLen := calldataload(proofStartAddress)
            proofStartAddress := add(proofStartAddress, 32)
        }

        ProofCalldataInfo[] memory proofCalldataInfo = new ProofCalldataInfo[](proofLen);

        uint16 i;
        for (i = 0; i < proofLen; i++) {
            uint256 elementStartAddress;
            uint256 elementLen;

            assembly {
                let elementStartAddressAddress := add(proofStartAddress, mul(i, 32))
                elementStartAddress := add(calldataload(elementStartAddressAddress), proofStartAddress)
                elementLen := calldataload(elementStartAddress)
                // add 32 bytes since the first word is the element length
                elementStartAddress := add(elementStartAddress, 32)
            }

            proofCalldataInfo[i].calldataAddress = elementStartAddress;
            proofCalldataInfo[i].len = elementLen;

            // TODO:  Make blake2b work with calldata
            bytes32 nodeDigest = Bytes.toBytes32(Blake2b.blake2b(proof[i], 32));
            proofCalldataInfo[i].digest = nodeDigest;
        }

        // Start with looking up the node that maps to the root hash
        SubstrateTrieDB.NodeCursor memory nodeCursor;
        nodeCursor.nodeHash = root;
        nodeCursor.cursor = proofCalldataInfo[TrieNodeLookup(proofCalldataInfo, root)].calldataAddress;

        ValueInfo memory valueInfo;
        SubstrateTrieDB.ChildNodeHandle[NUM_CHILDREN] memory children;
        for (i = 0; i < MAX_NUM_PROOF_NODES; i++) {
            keyNibbleCursor = processNode(
                nodeCursor,
                valueInfo,
                children,
                proofCalldataInfo,
                keyNibbleCursor,
                keyAddress
            );

            if (valueInfo.found) {
                break;
            }
        }

        // If the key is for the authority event list, then decode it and hash the result
        // If the key is for the authority set id, then decode it to a uint64
        bytes32 authoritySetDigest;
        uint64 authoritySetId;
        if (authEventListPostProcess) {
            authoritySetDigest = decodeAuthoritySetCalldata(valueInfo);
        } else {
            authoritySetId = ScaleCodec.decodeUint64Calldata(valueInfo.cursor);
        }

        return (authoritySetId, authoritySetDigest);
    }

    function TrieNodeLookup(ProofCalldataInfo[] memory proofCalldataInfo, bytes32 digest)
        internal
        pure
        returns (uint256 i)
    {
        for (i = 0; i < proofCalldataInfo.length; i++) {
            if (proofCalldataInfo[i].digest == digest) {
                return i;
            }
        }
        revert("TrieNodeLookup failed");
    }
}
