use std::{net::{IpAddr, Ipv6Addr, SocketAddr}, time::SystemTime};

use futures::{future, prelude::*};
use plonky2_field::goldilocks_field::GoldilocksField;
use plonky2::plonk::circuit_data::CircuitData;
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use subxt::ext::sp_core::H256;
use service::{C, D, ProofGenerator, create_header_validation_circuit, generate_header_validation_proof};
use succinct_avail_proof_generators::avail::VerifySubchainTarget;

static mut HEADER_VALIDATION_CIRCUIT: Option<CircuitData<GoldilocksField, C, D>> = None;
static mut HEADER_VALIDATION_TARGETS: Option<VerifySubchainTarget> = None;

#[derive(Clone)]
struct ProofGeneratorServer(SocketAddr);

#[tarpc::server]
impl ProofGenerator for ProofGeneratorServer {
    async fn generate_header_proof(self, _: context::Context, previous_block_hash: H256, block_hash: H256, header: Vec<u8>) -> String {
        println!("Got a generate_header_proof request with previous_block_hash: {:?} and block_hash: {:?}", previous_block_hash, block_hash);

        unsafe {
            let proof_gen_start_time = SystemTime::now();
            let header_validation_target = HEADER_VALIDATION_TARGETS.clone().unwrap();
            println!("calling generate_header_validation_proof");
            let proof = generate_header_validation_proof(&HEADER_VALIDATION_CIRCUIT, previous_block_hash, header, header_validation_target);
            let proof_gen_end_time = SystemTime::now();
            let proof_gen_duration = proof_gen_end_time.duration_since(proof_gen_start_time).unwrap();    
            if proof.is_some() {
                println!("proof generated - time: {:?}", proof_gen_duration);
                let verification_res = HEADER_VALIDATION_CIRCUIT.as_ref().unwrap().verify(proof.unwrap());
                if !verification_res.is_err() {
                    println!("proof verification succeeded");
                } else {
                    println!("proof verification failed");
                }
            } else {
                println!("failed to generate proof");
            }
        }

        return "hello".to_string();
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()>  {
    let (header_validation_circuit, header_validation_targets) = create_header_validation_circuit();
    unsafe {
        HEADER_VALIDATION_CIRCUIT = Some(header_validation_circuit);
        HEADER_VALIDATION_TARGETS = Some(header_validation_targets);
    }

    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 52356);
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    println!("Listening on port {}", listener.local_addr().port());
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = ProofGeneratorServer(channel.transport().peer_addr().unwrap());
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}